\documentclass[12pt, a4paper, oneside, romanian]{teza-upb}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{babel}
\usepackage{graphicx}
\usepackage{babel}
\usepackage{color}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage[
  bookmarks,
  bookmarksopen=true,
  pdftitle={licenta},
  linktocpage]{hyperref}


\singlespacing

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%cod colorat
\usepackage{listings}
\usepackage{color}
 
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  ndkeywords={class, export, boolean, throw, implements, import, this},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]"
}

\lstset{language=JavaScript}

\lstdefinestyle{mystyle}{
	language=JavaScript,
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
  	ndkeywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
  	identifierstyle=\color{black},
    stringstyle=\color{codepurple},
	basicstyle=\ttfamily\scriptsize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
 
\lstset{style=mystyle}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\author{Albert-Lucian LUTA}

\title{Includerea instrumentelor de predare-testare într-o aplicație e-learning}


\facultatea{Facultatea de Electronică, Telecomunicații și Tehnologia Informației}
\tiplucrare{diploma}
\domeniu{Calculatoare și Tehnologia Informației}
\catedra{Telecomunicații}
\campus{Leu} 
\program{Ingineria Informației}
\titlulobtinut{Inginer}
\director{Ş.L.Dr.Ing. Elena Cristina STOICA} 

\submissionmonth{Iunie} 
\submissionyear{2021} 

\beforepreface
\listoffigures
\listoftables
\abbreviations{ 
	SPA = Single Page Aplication\\
	CSR = Client Side Rendering\\
	SSR = Server Side Rendering\\
	SSG = Static Site Generation\\
	ISR = Incremental Static Regeneration\\
	HMR = Hot Module Replacement\\
	API = Aplication Programming Interface\\
	SEO = Search Engine Optimization\\
	FCP = First Contentful Paint
}
\afterpreface 

\chapter*{Introducere}
\addcontentsline{toc}{chapter}{Introducere}

\section{Scopul Proiectului}

Contextul actual a accelerat, fie că ne-am dorit sau nu, procesul de învăţare online. Chiar dacă mulţi dintre elevi şi profesori nu au fost pregătiţi pentru asta, unii nici nu şi-au dorit, acum predarea prin intermediul internetului a devenit o necesitate.\cite{liferoplatform}

Proiectul are rolul de a crea o platforma prin care universitatile sa isi poata desfasura activitatea de predare si testare intr-un mod usor, rapid si eficient.

\section{Descrierea proiectului}

Se va dezvolta o aplicatie web, cu ajutorul careia universitatile isi vor putea adauga si imparti utilizatorii in 3 roluri: Administrator, Profesor si Student. In functie de acest rol, vor exista functionalitati diferite prin care un utilizator poate interactiona cu platforma.

Studentii vor avea acces in orice moment la materialele atasate de catre profesori, pentru studiul independent in afara orelor de curs si pentru o aprofundare mai buna a materiei. Acestia vor putea accesa sarcinile la care sunt atribuiti de catre profesor si vor putea incarca pana la o data limita materialele la care au lucrat, ulterior fiind notati. Testele se vor tine in aproximativ aceeasi maniera, va exista o data de incepere si una de inchidere a testului, timp in care studentii vor trebui sa raspunda la toate intrebarile pentru a obtine punctajul maxim.

Profesorii vor putea atasa materiale, crea si configura sarcini de lucru si teste pentru studenti. Acestia vor avea posibilitatea de a imparti intr-un mod logic materialele in functie de sectiunile pe care le creeaza la fiecare materie.

Administratorii vor avea avea acces la toate functionalitatile de mai sus, iar pe langa acestea, vor putea adauga utilizatori, configura rolul si materiile de care apartin, crea, edita sau sterge facultati si materii.

Fiind o aplicatie web, am ales sa folosesc integral limbajul de programare TypeScript, atat pentru frontend, cat si pentru backend. Folosing un singur limbaj pentru intreg proiectul, dezvoltarea acestuia devine mai facila.

\chapter{Tehnologii folosite}

În acest capitol se vor prezenta tehnologiile folosite pe parcursul realizării aplicației, cum ar fi: limbaj de programare folosit, framework-uri. Pentru fiecare dintre acestea vor fi prezentate caracteristici importante ce au dus la alegerea lor în realizarea proiectului.

\section{Limbaj de programare}

Dupa 20 de ani de la introducerea sa în comunitatea de programare, JavaScript este acum unul dintre cele mai răspândite limbaje multi-platformă create vreodată. Începând ca un limbaj mic de scriptare pentru adăugarea de interactivitate trivială paginilor web, JavaScript a devenit un limbaj de alegere atât pentru aplicațiile frontend, cât și pentru cele backend de orice dimensiune. În timp ce dimensiunea, domeniul de aplicare și complexitatea programelor scrise în JavaScript au crescut exponențial, capacitatea limbajului JavaScript de a exprima relațiile dintre diferitele unități de cod nu s-a schimbat. Combinată cu semantica destul de particulară a timpului de rulare JavaScript, această nepotrivire între limbă și complexitatea programului a făcut ca dezvoltarea JavaScript să fie o sarcină dificil de gestionat pe scară larga.\cite{typescriptlangorgintro}

Cele mai frecvente tipuri de erori pe care programatorii le scriu pot fi descrise ca erori de tip de date: s-a folosit un anumit tip de valoare în care se aștepta un alt tip de valoare. Acest lucru s-ar putea datora unor greșeli de scriere simple, sau a unor greseli de înțelegere a unui API, a unor ipoteze incorecte despre comportamentul în timpul rulării sau a altor erori. Scopul limbajului TypeScript este de a analiza static programele JavaScript - cu alte cuvinte, un instrument care se asigura ca tipurile de date sunt corecte.\cite{typescriptlangorgintro}\\

Un lucru interesant este faptul ca limbajul TypeScript este un proiect open-source\footnote{Proiect software ``public'' -- oricine are acces de a citi, adauga sau modifica codul sursa, moderat de obicei de un grup restrans}, inceput si mentinut de Microsoft, dar la care poate contribui oricine pe GitHub\footnote{Serviciu de gazduire web pentru proiecte software}.\\

Putem observa mai jos aceeasi functie simpla de suma a doua numere scrisa in cele 2 limbaje, JavaScript si TypeScript. In cazul limbajului JavaScript, functia accepta parametri de orice tip de date, lucru care poate duce la posibile erori daca nu suntem atenti in momentul utilizarii. In cazul TypeScript, compilatorul ne atentioneaza daca tipul de date al argumentelor nu este corect.

\lstinputlisting{cod/suma-2-numere.js}
\lstinputlisting{cod/suma-2-numere.ts}

\section{Frontend}

\subsection{React}

React este un framework open-source pentru JavaScript inceput de FaceBook, ce ne permite sa cream rapid un frontend scalabil si usor de utilizat pentru aplicatiile web. Este unul dintre cele mai populare in randul programatorilor dar si al mediului de afaceri, multumita avantajelor sale in dezvoltarea aplicatiilor web\cite{rowebreact}:

\begin{itemize}
	\item Timp de iteratie mic, ideal pentru companii si proiecte dinamice
	\item Permite scrierea unui cod modular si reutilizabil
	\item Usor de scalat si mentinut, ideal pentru proiecte complexe pe care lucreaza mai multe echipe in acelasi timp
	\item Cunostintele se pot folosi pentru a crea aplicatii mobile native, cu ajutorul framework-ului React Native
\end{itemize}

\subsubsection{SPA}

Single Page Application -- Website-urile create cu ajutorul framework-ului React sunt formate dintr-o singura pagina Html goala si unul sau mai multe fisiere JavaScript care se vor ocupa de afisarea si interactiunea elementelor din pagina. Acest lucru vine atat cu avantaje, cat si cu dezavantaje.

Avantajul principal este interactivitatea, odata ce codul JavaScript a fost descarcat si rulat, aplicatia se va simti exact ca una nativa, totul va fi fluid, instant si nu se va mai astepta dupa incarcarea paginilor, aceasta facandu-se ``virtual'' de catre codul JavaScript(in realitate totul se intampla intr-o singura pagina -- root(index.html)).

Dezavantajele principale sunt reprezentate de SEO si FCP. Deoarece pagina initiala este goala(inainte sa ruleze codul JavaScript pe browser), algoritmii de indexare nu vor putea detecta continutul de pe pagina(deoarece inca nu exista), iar pagina va primi un scor mic. Aceasta problema se resimte defapt decat in momentul in care vrem sa avem mai multe pagini care sa fie corect indexate(ex: un magazin online). Deoarece tot codul JavaScript trebuie descarcat si rulat inainte sa putem vedea ceva pe pagina, in cazul conexiunilor slabe la internet sau a dispozitivelor cu putere de procesare mica, timpul pana in momentul in care elementele de pe pagina vor fi vizibile si interactive s-ar putea sa devina mare.

\subsection{Next}

Next este un framework open-source pentru React inceput de Vercel, ce ne permite sa utilizam SSR, SSG si ISR usor in cadrul React, pentru a putea optimiza atat performanta, cat si SEO-ul website-urilor. Principalele avantaje sunt:

\begin{itemize}
	\item SSR, SSG, ISR
	\item Împărțirea automată a codului
	\item Optimizare automata a imaginilor
\end{itemize}

\subsubsection{CSR, SSR, SSG, ISR}

CSR(Client Side Rendering) -- Modul implicit de functionare al framework-ului React, cand utilizatorul acceseaza aplicatia web, browser-ul primeste o pagina goala(index.html) pe care va incepe sa o parseze. Cand ajunge la tag-ul ``script'' va trimite un request pentru fisierul JavaScript, pe care ulterior il ruleaza. Dupa ce se termina rularea, pagina va deveni interactiva.\\

SSR(Server Side Rendering) -- La primul request al utilizatorului catre server, in loc sa primeasca o pagina goala, serverul ruleaza codul JavaScript, care va construi o noua pagina Html si pe care o va livra in locul paginii goale. Acest lucru ajuta algoritmii de indexare sa ofere un scor corect paginilor.\\

SSG(Static Site Generation) -- Serverul va realiza aceeasi operatiune ca la SSR, doar ca in loc sa se intample cand utilizatorul acceseaza pagina, se va intampla in prealabil, intr-un proces numit build\footnote{Compilarea tuturor fisierelor sursa in fisiere executabile}.\\

ISR(Incremental Static Regeneration) -- O combinatie intre SSR si SSG, in care nu toate paginile se construiesc la buid, ci doar cele pe care le alegem, restul fiind construite in momentul in care un oarecare utilizator vrea sa o acceseze, aceasta va fi salvata pentru a fi servita si urmatorilor utilizatori.

\subsubsection{Împărțirea automată a codului}

In mod implicit, in momentul de build se va crea un singur fisier executabil din cele sursa, care va contine codul pentru toate paginile. Acest lucru va face ca indiferent ce pagina va fi accesata de catre utilizator, acesta sa primeasca codul pentru toate. Next optimizeaza automat acest lucru, creand mai multe fisiere executabile, in functie de pagina accesata. Astfel, utilizatorul va primi doar codul de care are strict nevoie pentru a rula pagina respectiva.

\subsubsection{Optimizare automata a imaginilor}

Optimizarea automată a imaginilor permite redimensionarea, optimizarea și servirea imaginilor în formate moderne precum WebP atunci când browserul o acceptă. Acest lucru evită transportul de imagini mari pe dispozitive cu o fereastră mai mică. De asemenea, imaginile sunt incarcate lenes\footnote{Imaginile sunt incarcate doar in momentul in care ar trebui sa le vedem}.\cite{nextimageoptimization}

\section{Backend}

\subsection{Node}

\subsection{Express}

\subsection{Nest}

\chapter{Securitate}

\chapter*{Concluzii}
\addcontentsline{toc}{chapter}{Concluzii}

\bibliographystyle{unsrt}
\bibliography{referinte}

% \appendix

\end{document}

